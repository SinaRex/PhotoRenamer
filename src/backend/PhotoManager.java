package backend;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.io.Serializable;
import java.util.*;

public class PhotoManager implements Serializable{
	/**
	 * A serial version UID generated by Eclipse.
	 */
	private static final long serialVersionUID = -1683873050768108812L;
	
	/**
	 * The data path to save the serialized file.
	 */
	private String dataPath = getCurrentDirPath();

	/**
	 * the root of the FileNode fileTree.
	 */
	private File root;
	
	/**
	 * the fileTree that represents the structure of the selected directory.
	 */
	private FileNode fileTree;
	
	/**
	 * The list of acceptable OS image extension.
	 */
	private final static String[] LIST_OF_EXTENTIONS = {"JPEG", "JPG", "PNG", "TIFF", 
			"GIF", "BMP"};
	
	/**
	 * This represents a user-friendly representation of the directory tree.
	 */
	public StringBuffer contents;
	
	/**
	 * This represents a map from each directory's path to list of Photos.
	 */
	public Map<String, ArrayList<Photo>> directoryToPhotos;

    /**
     * The only instance of LogSystem class to record a log of operations done
     * on the photos.
     */
	public static LogSystem logger = LogSystem.getInstance();
	
	/**
	 * A Directory chooser to construct a map of directories to list of Photos.
	 * 
	 * @param file the root node.
	 */
	public PhotoManager(File file){

		this.root = file;
		File f = new File(this.dataPath);

		// making a data.ser file which is where everything relevant is saved for running
		// photoRenamer.
		if (f.exists()) {
			try(InputStream fileInput = new FileInputStream(this.dataPath)){
				InputStream buffer = new BufferedInputStream(fileInput);
				ObjectInput input = new ObjectInputStream(buffer);
				
				this.directoryToPhotos = (Map<String, ArrayList<Photo>>) input.readObject();
			}catch(IOException | ClassNotFoundException e){
				e.printStackTrace();
			}
        }else{
			this.directoryToPhotos = new HashMap<String, ArrayList<Photo>>();
		}
	}

	/**
	 * Find and return the data path of this current directory data path of the serialized file. This
	 * is done so the program can run on most operating systems.
	 *
	 * @return the data path of this current directory data path of the data file
	 */
	private String getCurrentDirPath() {
		String workSpaceDir = System.getProperty("user.dir");
		String dataPath = workSpaceDir + File.separator + "bin" ;
		File file = new File(dataPath, "data");
		file.mkdirs();
		return file.getAbsolutePath() + File.separator + "data.ser";
	}

	/**
	 * Construct the tree. Additionally, build the content, 
	 * build the map and save this map to the serialized file 
	 * of this Directory. 
	 */
	public void openDirectory(){
		this.fileTree = new FileNode(root.getName(), null, FileType.DIRECTORY, root);
		buildTree(this.root, this.fileTree);
		this.contents = new StringBuffer();
		buildDirectoryContents(fileTree, this.contents, "");
		buildMap(this.fileTree);
		saveToFile();
	}
	
	/**
	 * Recursively construct the Tree with the given File root and FileNode tree.
	 * 
	 * @param file
	 * 		 the root of the FileNode fileTree.
	 * @param curr
	 *		 the fileTree that represents the structure of the selected directory.
	 */
	private void buildTree(File file, FileNode curr) {
		// Base case is when current is not a directory.
		if (curr.isDirectory()){
			File[] subdic = file.listFiles();
			for (int i = 0; i < subdic.length; i++){
				String extension = getExtension(subdic[i]).toUpperCase();
				if (subdic[i].isDirectory()){
					FileNode child = new FileNode(subdic[i].getName(), curr, FileType.DIRECTORY, subdic[i]);
					curr.addChild(subdic[i].getName(), child);
					buildTree(subdic[i], child);
				}else if(subdic[i].isFile() && Arrays.asList(LIST_OF_EXTENTIONS).contains(extension)){
					FileNode child = new FileNode(subdic[i].getName(), curr, FileType.FILE, subdic[i]);
					curr.addChild(subdic[i].getName(), child);
				}
			}
		}
		
	}
	
	/**
	 * Recursively build directory contents of this Directory.
	 * 
	 * @param fileNode
	 * 			the fileNode of the root directory.
	 * @param contents
	 * 			the content to be added.
	 * @param prefix
	 * 			the constant that represents "--" which is used for subdirectories contents.
	 */
	private static void buildDirectoryContents(FileNode fileNode, StringBuffer contents, String prefix) {
		contents.append(prefix);
		if (fileNode.isDirectory()){
			contents.append(fileNode.getName() + " (Directory)");
		}else{
		contents.append(fileNode.getName());
		}
		if (fileNode.isDirectory()){
			prefix += "--";
			for (FileNode f : fileNode.getChildren()){
				buildDirectoryContents(f, contents.append('\n'), prefix);
			}
		}
	}
	
	/**
	 * Return the OS extension of the File file.
	 * 
	 * @param file
	 * 		the OS file used for getting the extension
	 * @return
	 * 		the extension of the Photo.
	 */
	private static String getExtension(File file){
		String fileName = file.getName();
		int lastIndex = fileName.lastIndexOf('.');
		if (lastIndex != 0 && lastIndex != -1){
			return fileName.substring(lastIndex + 1);
		}
		return "";	
	}
	
	/**
	 * Return the name of the File file without the extension.
	 * 
	 * @param file
	 * 		the OS file used for getting the name
	 * @return
	 * 		the name of the photo file without the extension
	 */
	private static String getNameOnly(File file){
		String fileName = file.getName();
		int lastIndex = fileName.lastIndexOf('.');
		if (lastIndex != 0 && lastIndex != -1){
			return fileName.substring(0, lastIndex);
		}
		return "";	
	}
	
	/**
	 * Return a list of Photos with he given node directory.
	 * 
	 * @param node
	 * 		the node directory
	 * @return
	 * 		the list of photos
	 */
	private static ArrayList<Photo> getPhotoList(FileNode node){
		ArrayList<Photo> photos = new ArrayList<> ();
		for (FileNode n : node.getChildren()){
			if (!n.isDirectory()){
				photos.add(new Photo(n.getFile(), getNameOnly(n.getFile()), getExtension(n.getFile())));
			}
		}
		return photos;
	}
	
	/**
	 * Recursively construct a map of directory to list of Photos
	 * 
	 * @param f
	 * 		the given directory node
	 */
	private void buildMap(FileNode f){
		if (f.isDirectory() && !this.directoryToPhotos.containsKey(f.getFile().getAbsolutePath())){
			directoryToPhotos.put(f.getFile().getAbsolutePath(), getPhotoList(f));
		}
		for (FileNode n: f.getChildren()){
			if (n.isDirectory() && !this.directoryToPhotos.containsKey(n.getFile().getAbsolutePath())){
				buildMap(n);
			}
		}
	}

	/**
	 * Serializing the map of directory to list of photos.
	 */
	public void saveToFile(){
		try(OutputStream file = new FileOutputStream(this.dataPath);){
			OutputStream buffer = new BufferedOutputStream(file);
	        ObjectOutput output = new ObjectOutputStream(buffer);
	        
	        /*serialize the Map of directories to list of Photos*/
	        output.writeObject(this.directoryToPhotos);
	        output.close();
		}catch(IOException e){
			e.printStackTrace();
		}
        
    }
	
	/**
	 * Return a photo with given its name without the extension.
	 * This is only used for making unittesting easier.
	 * 
	 * precondition: assume all the name of photos are unique in this directory.
	 * 
	 * @param name
	 * 		name of the Photo to be looked for
	 * @return
	 * 		the Photo object with its given name
	 */
	public Photo lookForPhoto(String name){
		/*Assuming all the photo names are unique*/
		Photo foundPhoto = null;
		Collection<ArrayList<Photo>> allPhotos =  this.directoryToPhotos.values();
		for(ArrayList<Photo> sublist: allPhotos){
			for(Photo p: sublist){
				if(p.getTaggedName().equals(name)){
					foundPhoto = p;
				}
			}
		}
		return foundPhoto;
		
	}


    /**
     * Return a list of all used current tags in this directory.
     *
     * @return
     * 		a list of string which represent the label of each tag.
     */
	public ArrayList<String> getAllCurrentTags(){
		ArrayList<String> list = new ArrayList<>();
		
		Collection<ArrayList<Photo>> allPhotos =  this.directoryToPhotos.values();
		for(ArrayList<Photo> sublist: allPhotos){
			for(Photo p: sublist){
				for(Tag t: p.getTags()){
					if(!list.contains(t.label)){
						list.add(t.label);
					}
				}
				}
			}
		return list;
		}
	
	/**
	 * Revert every single Photo in this directory to their original status.
	 */
	public void revertAll(){
		Collection<ArrayList<Photo>> allPhotos =  this.directoryToPhotos.values();
		for(ArrayList<Photo> sublist: allPhotos){
			for(Photo p: sublist){
				p.revertToDate(p.getDatesSorted().get(0));
				
				}
			}
	}
	
	/**
	 * Return the the most common tag used in this directory.
	 * 
	 * @return
	 * 		the most common tag
	 */
	public String getMostCommonTag(){
		Collection<ArrayList<Photo>> allPhotos =  this.directoryToPhotos.values();

        // We make a map of photo names to number of tags.
		Map<String,Integer> NameToTagCounter = new HashMap<>();


		String mostCommonTag = "None";
		Integer maxtimes = 0;
		/*use the counter if constant maxtimes to find the Tag with most time used */
		for(ArrayList<Photo> sublist: allPhotos){
			for(Photo p: sublist){
				for (Tag t : p.getTags()){
					if(NameToTagCounter.containsKey(t.label)){
						NameToTagCounter.put(t.label,NameToTagCounter.get(t.label) + 1);
						if (NameToTagCounter.get(t.label) >= maxtimes){
							maxtimes = NameToTagCounter.get(t.label);
							mostCommonTag = t.label;
						}
					}
					else{
						NameToTagCounter.put(t.label, 1);
						if (NameToTagCounter.get(t.label) >= maxtimes){
							maxtimes = NameToTagCounter.get(t.label);
							mostCommonTag = t.label;
						}
					}
				}	
			}
		}
		return mostCommonTag;
	}
	
	/**
	 * Return the Photo with the most tags in this directory.
	 * @return
	 * 		the photo with the most number of tags.
	 */
	public Photo getMostTaggedPhoto() {
		Collection<ArrayList<Photo>> allPhotos =  this.directoryToPhotos.values();
		Photo mostTagged = null;
		for(ArrayList<Photo> sublist: allPhotos){
			for(Photo p: sublist){
				if (mostTagged == null || p.getTags().size() >= mostTagged.getTags().size()) {
					mostTagged = p;
				}
				if (mostTagged.getTags().size() == 0){
					mostTagged = null;
				}
			}
		}
		return mostTagged;
	}

    /**
     * Find all images only from the contents and add them to
     * the list of images.
     *
     */
    public void makeListOfPhotos(List<Photo> listOfPhotos, File file) {
        ArrayList<Photo> temp = this.directoryToPhotos.get(file.getAbsolutePath());
        if (temp!= null){
            for(Photo p : temp) {
                listOfPhotos.add(p);
            }
            File[] fileArray = file.listFiles();
            if(fileArray != null){
                for(File c : fileArray) {
                    makeListOfPhotos(listOfPhotos, c);
                }
            }
        }
    }

}
